<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TIA Status Report: Multi-Agent Problem Solving Through Explicit Models</title>
    <style>
      body { margin: 0; padding: 48px 20px; font-family: "Helvetica Neue", Arial, sans-serif; background: #f7f4ef; color: #1f1b16; }
      main { max-width: 920px; margin: 0 auto; background: #fffdf9; padding: 48px; border: 1px solid #e3d8c7; box-shadow: 6px 8px 0 #e3d8c7; }
      h1, h2, h3 { font-weight: 600; margin-top: 2rem; }
      pre { background: #1f1b16; color: #f7f4ef; padding: 16px; overflow: auto; }
      code { font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, monospace; }
      a { color: #8a3b12; }
      img { max-width: 100%; height: auto; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border: 1px solid #e3d8c7; padding: 8px; }
    </style>
  </head>
  <body>
    <main>
      <h1>TIA Status Report: Multi-Agent Problem Solving Through Explicit Models</h1>
<p>Date: 2025-12-28</p>
<p>Status: current</p>
<h2>Overview</h2>
<p>TIA (The Intelligence Agency) is a multi-agent system built on federated protocols: XMPP for real-time messaging, RDF for knowledge representation, and semantic vocabularies for agent coordination. The system implements Model-First Reasoning, a two-phase approach where specialized agents collaboratively construct an explicit problem model before generating solutions.</p>
<p>As of this date, the system demonstrates end-to-end problem-solving capabilities. A community of autonomous agents can debate solution approaches, conduct planning polls to select reasoning strategies, and execute either logic-based (Prolog), consensus-based (debate), or adaptive (Golem) workflows. The process is functional but remains chaotic, which is typical for systems exploring emergent coordination patterns.</p>
<h2>Architectural Foundation</h2>
<h3>Protocol Stack</h3>
<p>The architecture rests on three protocol layers:</p>
<ol>
<li><p><strong>XMPP Layer</strong>: Provides federated messaging and multi-user chat rooms. Agents connect to an XMPP server, join designated rooms, and exchange messages. The protocol handles presence, reconnection, and room management without requiring custom transport infrastructure.</p>
</li>
<li><p><strong>RDF Configuration Layer</strong>: Agent profiles, capabilities, and system configuration are expressed in RDF Turtle files. This enables runtime introspection and modification without code changes. Profiles declare XMPP credentials, supported language modes, and agent-specific capabilities.</p>
</li>
<li><p><strong>Lingue Protocol Layer</strong>: Handles language mode negotiation between agents. When two agents need to exchange structured data, they negotiate a common language mode (Prolog programs, SPARQL queries, IBIS dialogue, or RDF model fragments). This allows heterogeneous agents to coordinate without shared implementation details.</p>
</li>
</ol>
<h3>Agent Runtime Model</h3>
<p>The core runtime component is AgentRunner, which manages the agent lifecycle: XMPP connection, room joining, message routing, and command parsing. Agents implement a provider interface with a handle method that processes incoming messages. The system uses explicit dependency injection—providers receive their dependencies through constructor arguments rather than relying on global state or service locators.</p>
<p>Providers range from simple implementations (Demo agent echoes messages) to complex ones (Coordinator orchestrates multi-room, multi-phase workflows). Some providers extend BaseLLMProvider to wrap API clients from Mistral or Groq, while others like PrologProvider implement specialized reasoning engines using tau-prolog.</p>
<h3>Configuration Model</h3>
<p>Runtime behavior is determined by RDF profiles rather than hard-coded defaults. XMPP credentials live in a secrets file (gitignored), API keys come from environment variables, and all other configuration flows through profile files. This separation enables the same codebase to launch different agent personalities by loading different profiles. The mistral-base profile, for instance, defines common LLM settings that mistral-analyst and mistral-creative inherit and specialize.</p>
<h2>Model-First Reasoning</h2>
<h3>The Core Innovation</h3>
<p>Model-First Reasoning separates problem modeling from problem solving. In traditional LLM-based systems, the model attempts both simultaneously, which increases the likelihood of hallucinations and logical inconsistencies. MFR enforces a two-phase process:</p>
<p><strong>Phase 1: Model Construction</strong> - Agents collaboratively define:</p>
<ul>
<li>Entities (the objects in the problem domain)</li>
<li>State variables (mutable properties of entities)</li>
<li>Actions (transformations with preconditions and effects)</li>
<li>Constraints (invariants that must hold in any valid solution)</li>
</ul>
<p><strong>Phase 2: Constrained Reasoning</strong> - All solution generation operates strictly within the validated model&#39;s bounds.</p>
<p>This approach produces verifiable solutions because constraints are explicit and checkable. It also enables compositional expertise: different agents contribute specialized knowledge to different aspects of the model.</p>
<h3>Agent Specialization</h3>
<p>The MFR workflow distributes responsibilities across specialized agents working together in the general room:</p>
<ul>
<li><strong>Coordinator</strong>: Orchestrates the protocol, manages state machines, performs SHACL validation, and synthesizes multi-agent contributions.</li>
<li><strong>Mistral</strong>: Interprets natural language problem descriptions, extracts initial entities and goals, generates explanations.</li>
<li><strong>Data</strong>: Grounds entities to knowledge bases (Wikidata, DBpedia), discovers relationships, validates entity properties.</li>
<li><strong>Prolog</strong>: Models actions with preconditions and effects, validates state transitions, generates solution plans.</li>
<li><strong>MFR Semantic</strong>: Identifies constraints from domain knowledge, checks logical coherence, detects conflicts.</li>
<li><strong>Executor</strong>: Translates high-level plans into executable Prolog programs.</li>
<li><strong>Golem</strong>: Adapts to assigned roles dynamically, particularly for logic-focused reasoning when planning polls select the golem-logic route.</li>
</ul>
<h3>Room Organization</h3>
<p>The system uses two primary rooms:</p>
<ul>
<li><code>general@conference.tensegrity.it</code>: Primary room where the coordinator receives requests and coordinates the MFR workflow with all participating agents</li>
<li><code>log@conference.tensegrity.it</code>: Verbose traces, Prolog payloads, consensus logs, and detailed system diagnostics</li>
</ul>
<p>All MFR agents participate in the general room where phase transitions, contribution requests, and model exchanges occur. The log room captures detailed traces without cluttering the main conversation, allowing users to focus on the problem-solving process while developers can monitor the detailed protocol execution.</p>
<h3>RDF-Based Model Representation</h3>
<p>Problem models are RDF graphs with provenance tracking. Each contribution includes metadata about which agent produced it and when. The coordinator merges contributions into a unified graph and validates it against SHACL shapes that define model completeness requirements (entities present, actions defined, goals specified, constraints identified).</p>
<p>When validation fails, the system enters a negotiation phase where agents can propose amendments or challenge conflicting contributions. This is still a developing area—current implementations handle basic conflict detection but lack sophisticated resolution strategies.</p>
<h2>The Lingue Protocol</h2>
<h3>Language Mode Negotiation</h3>
<p>Agents advertise supported language modes via XEP-0030 service discovery. When agent A needs to send structured data to agent B, it offers one or more language modes. Agent B selects a supported mode from the offer, and both sides store the negotiated mode for that peer relationship.</p>
<p>This negotiation happens at the start of exchanges and can be renegotiated if requirements change. The mechanism allows heterogeneous agents to discover compatible communication modes without requiring global configuration or format mandates.</p>
<h3>Structured Payloads</h3>
<p>Lingue defines handlers for different content types:</p>
<ul>
<li><strong>HumanChat</strong>: Plain text for human-readable messages</li>
<li><strong>IBISText</strong>: Issue-Based Information System dialogue (positions, arguments, questions)</li>
<li><strong>PrologProgram</strong>: Prolog clause sets and queries</li>
<li><strong>ProfileExchange</strong>: Agent capability descriptions</li>
<li><strong>SparqlQuery</strong>: SPARQL queries for knowledge retrieval</li>
<li><strong>ModelFirstRDF</strong>: RDF fragments for MFR contributions</li>
<li><strong>ModelNegotiation</strong>: JSON-based negotiation protocol for MFR phases</li>
<li><strong>ShaclValidation</strong>: Validation reports and constraint violations</li>
</ul>
<p>Handlers parse incoming payloads and route them to appropriate processing logic. They also serialize outgoing payloads according to the negotiated mode. This abstraction keeps agent providers isolated from serialization details.</p>
<h3>ASK/TELL Semantics</h3>
<p>The system maps ASK/TELL patterns to IBIS vocabulary:</p>
<ul>
<li>ASK maps to ibis:Issue or ibis:Question</li>
<li>TELL maps to ibis:Position or ibis:Argument</li>
</ul>
<p>This provides a lightweight semantics for agent-to-agent information exchange without requiring full commitment to formal knowledge bases.</p>
<h2>Debate and Consensus Mechanisms</h2>
<h3>Planning Polls</h3>
<p>When a user poses a problem with the prefix <code>Q:</code>, the coordinator initiates a planning poll. The Chair agent moderates a structured debate where agents propose reasoning strategies: logic-based (Prolog), consensus-based (debate), or adaptive (golem-logic).</p>
<p>Agents respond with explicit Position markers, and the Chair collects these responses. The coordinator analyzes the positions and selects a route based on the poll results. This meta-reasoning step allows the system to adapt its problem-solving strategy based on agent expertise assessments.</p>
<h3>Structured Debate</h3>
<p>The debating society layer enforces Position/Support/Objection markers. The Chair prompts for explicit positions rather than accepting free-form text, which makes parsing and analysis reliable. The Recorder captures minutes and verbose traces to the log room, preserving the decision-making history.</p>
<p>This structured approach prevents the common failure mode of multi-agent systems where agents talk past each other or drift into unproductive tangents. The explicit markers create a machine-readable debate transcript.</p>
<h2>Model Context Protocol Integration</h2>
<h3>Dual Role Architecture</h3>
<p>TIA acts both as an MCP server (exposing chat and Lingue tools to external clients) and as an MCP client (consuming tools from external servers).</p>
<p>As a server, TIA exposes:</p>
<ul>
<li><code>sendMessage</code>: Send messages to XMPP rooms or direct JIDs</li>
<li><code>getRecentMessages</code>: Retrieve chat history</li>
<li><code>offerLingueMode</code>: Initiate language mode negotiation</li>
<li><code>summarizeLingue</code>: Generate IBIS-style summaries</li>
</ul>
<p>External clients like Claude Code or custom MCP clients can invoke these tools to participate in the agent society.</p>
<p>As a client, agents like Semem connect to external MCP servers to access knowledge stores, external APIs, or specialized tools. This bidirectional integration means TIA can both expose its capabilities and consume external services through a common protocol.</p>
<h3>Transport Flexibility</h3>
<p>The MCP implementation supports both stdio and in-memory transports. The stdio transport enables standard MCP client integration (Claude Desktop, Codex CLI), while the in-memory transport facilitates testing and embedded scenarios. The MCP loopback agent demonstrates the integration patterns by running a client bridge against a local echo server.</p>
<h2>Problem-Solving Strategies</h2>
<h3>Separation of Concerns</h3>
<p>The architecture enforces separation between:</p>
<ul>
<li>Protocol handling (XMPP connection, message parsing)</li>
<li>Domain logic (entity extraction, constraint identification, plan generation)</li>
<li>Coordination (orchestration, validation, synthesis)</li>
</ul>
<p>This separation enables independent evolution of components. The XMPP layer can be replaced with a different transport without affecting domain logic. Coordination strategies can change without modifying agent providers.</p>
<h3>Compositional Expertise</h3>
<p>Different agents contribute complementary knowledge:</p>
<ul>
<li>Natural language agents interpret human intent and generate explanations</li>
<li>Knowledge agents ground entities in authoritative sources</li>
<li>Logic agents model state transitions and generate plans</li>
<li>Semantic agents identify constraints and check consistency</li>
</ul>
<p>No single agent attempts to solve the entire problem. Instead, each contributes its specialized knowledge to a shared model, and the coordinator synthesizes the result.</p>
<h3>Explicit Validation</h3>
<p>SHACL shapes define what constitutes a valid problem model. The coordinator validates merged contributions against these shapes and reports specific violations. This explicit validation prevents silent failures where an incomplete model produces nonsensical solutions.</p>
<p>Validation operates at multiple levels:</p>
<ul>
<li>Syntactic: Is the RDF well-formed?</li>
<li>Structural: Are required properties present?</li>
<li>Semantic: Do entity relationships make sense?</li>
<li>Logical: Are constraints mutually consistent?</li>
</ul>
<p>Current implementations focus on syntactic and structural validation. Semantic and logical validation remain areas of active development.</p>
<h3>Provenance Tracking</h3>
<p>Every contribution includes metadata about its source agent and timestamp. This provenance information enables:</p>
<ul>
<li>Conflict resolution (preferring contributions from domain experts)</li>
<li>Debugging (tracing which agent introduced problematic information)</li>
<li>Explanation (showing users which agents contributed to the solution)</li>
<li>Trust metrics (tracking agent reliability over time)</li>
</ul>
<p>The provenance model is straightforward: each RDF statement includes a <code>mfr:contributedBy</code> property. More sophisticated provenance tracking (contribution revision history, confidence scores) is under consideration.</p>
<h2>Current Status and Observations</h2>
<h3>What Works</h3>
<p>The end-to-end flow operates: users can pose problems, agents construct models, validation occurs, solutions are generated, and explanations are returned. The planning poll mechanism successfully routes problems to appropriate reasoning strategies. The multi-room orchestration keeps phases organized and prevents message confusion.</p>
<p>The RDF-based configuration model proves effective for runtime introspection and modification. Adding a new agent requires writing a profile and a provider, without touching existing code. The Lingue negotiation allows agents with different capabilities to collaborate without prior coordination.</p>
<h3>Sources of Chaos</h3>
<p>The system exhibits several sources of unpredictability:</p>
<ol>
<li><p><strong>Timing Dependencies</strong>: Agents respond asynchronously, and the coordinator uses timeouts to collect contributions. If an agent is slow, its contribution may be excluded.</p>
</li>
<li><p><strong>LLM Variability</strong>: Responses from Mistral or Groq vary across invocations. The same problem can produce different entity extractions or constraint identifications.</p>
</li>
<li><p><strong>Negotiation Complexity</strong>: When models fail validation, the negotiation phase lacks sophisticated conflict resolution. Agents may propose amendments that introduce new conflicts.</p>
</li>
<li><p><strong>Message Volume</strong>: Complex problems generate substantial message traffic across rooms. The log room helps, but coordinating room membership and managing message routing remains challenging.</p>
</li>
<li><p><strong>State Machine Complexity</strong>: The MFR state machine has numerous states and transitions. Edge cases (timeouts, missing agents, malformed contributions) can leave sessions in unexpected states.</p>
</li>
</ol>
<p>These issues reflect the inherent complexity of multi-agent coordination rather than implementation defects. Reducing chaos requires either stricter protocols (less flexibility) or more sophisticated coordination mechanisms (more complexity).</p>
<h3>Development Priorities</h3>
<p>Current development focuses on:</p>
<ul>
<li>Improving conflict resolution during model validation</li>
<li>Refining the executor agent&#39;s plan-to-Prolog translation</li>
<li>Enhancing SHACL shapes for better validation coverage</li>
<li>Optimizing message routing to reduce log room traffic</li>
<li>Stabilizing the state machine with better timeout handling</li>
</ul>
<p>The system benefits from ongoing refactoring: no source file exceeds 500 lines, unit and integration tests run before and after changes, and configuration remains externalized in RDF profiles.</p>
<h2>Technical Lessons</h2>
<h3>Protocol Choices</h3>
<p>XMPP provides robust room management and reconnection handling without custom infrastructure. The federation model allows agents to run on different machines or networks. However, XMPP clients vary in their standards compliance, and debugging connection issues requires familiarity with XMPP semantics.</p>
<p>RDF offers expressiveness and extensibility for configuration and models. Tools for RDF manipulation exist, and SHACL provides a standard validation mechanism. The learning curve is steeper than JSON, but the payoff is runtime introspection and semantic interoperability.</p>
<p>MCP enables clean integration with external tools and clients. The protocol is simple enough to implement from scratch but standardized enough for broad compatibility. Dual-mode operation (server and client) in the same system proves valuable.</p>
<h3>Agent Coordination Patterns</h3>
<p>Explicit phase separation through multiple rooms works better than trying to coordinate everything in a single channel. Spatial organization mirrors cognitive organization—agents know where to listen based on what phase they participate in.</p>
<p>Language mode negotiation allows heterogeneous agents to collaborate without imposing a single data format. The negotiation overhead is minimal compared to the flexibility gained.</p>
<p>Provenance tracking in contributions is essential for debugging and explanation. Without knowing which agent produced which information, diagnosing problems becomes guesswork.</p>
<h3>Configuration as Data</h3>
<p>Externalizing configuration in RDF profiles enables runtime modification and supports the &quot;configuration is data&quot; principle. Agents can inspect their own profiles and other agents&#39; profiles to understand system capabilities. This introspection supports dynamic coordination strategies.</p>
<p>However, RDF editing is less accessible than JSON or YAML for users unfamiliar with semantic web technologies. Tooling improvements (profile validators, template generators) could lower the barrier.</p>
<h3>Testing Strategies</h3>
<p>The combination of unit tests, integration tests, and runnable example scripts provides good coverage. Example scripts serve dual purposes: demonstrations for users and smoke tests for developers. They ensure that documented workflows actually function.</p>
<p>The requirement to run tests before and after significant changes catches regressions. The prohibition on source files exceeding 500 lines forces appropriate modularization, which improves testability.</p>
<h2>Conclusion</h2>
<p>TIA demonstrates that multi-agent systems can perform complex problem-solving through explicit model construction and compositional expertise. The architecture separates concerns effectively: protocol handling, domain logic, and coordination operate independently. The use of open standards (XMPP, RDF, MCP) enables federated operation and external integration.</p>
<p>The system&#39;s current chaotic behavior reflects the genuine complexity of coordinating autonomous agents with varying capabilities and asynchronous communication patterns. This chaos is not a bug to be eliminated but a property to be understood and managed.</p>
<p>Future development will focus on improving conflict resolution, refining coordination mechanisms, and stabilizing edge cases. The foundational architecture—modular agents, explicit models, federated protocols—provides a solid basis for these improvements.</p>
<p>The end-to-end workflow functions. Agents collaborate, models are constructed and validated, solutions are generated and explained. The system works, and that makes it a platform for further exploration of multi-agent coordination patterns.</p>

    </main>
  </body>
</html>