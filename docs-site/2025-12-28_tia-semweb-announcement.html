<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ANN: TIA Intelligence Agency - Multi-Agent Problem Solving in a Chat Room</title>
    <style>
      body { margin: 0; padding: 48px 20px; font-family: "Helvetica Neue", Arial, sans-serif; background: #f7f4ef; color: #1f1b16; }
      main { max-width: 920px; margin: 0 auto; background: #fffdf9; padding: 48px; border: 1px solid #e3d8c7; box-shadow: 6px 8px 0 #e3d8c7; }
      h1, h2, h3 { font-weight: 600; margin-top: 2rem; }
      pre { background: #1f1b16; color: #f7f4ef; padding: 16px; overflow: auto; }
      code { font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, monospace; }
      a { color: #8a3b12; }
      img { max-width: 100%; height: auto; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border: 1px solid #e3d8c7; padding: 8px; }
    </style>
  </head>
  <body>
    <main>
      <h1>ANN: TIA Intelligence Agency - Multi-Agent Problem Solving in a Chat Room</h1>
<p>An RDF-heavy experiment.</p>
<p>Repo: <a href="https://github.com/danja/tia">https://github.com/danja/tia</a>
Live chat : <a href="https://tensegrity.it/chat/">https://tensegrity.it/chat/</a> (or use a standard XMPP client)</p>
<p>You need to register, but it&#39;s just simple username/password. You want to be in <code>general@conference.tensegrity.it</code>, watch <code>log@conference.tensegrity.it</code>. Most of the agents will respond if directly addressed. Pose a problem by prefixing a message with <code>Q:</code></p>
<p>I had Claude write the text below but I believe it&#39;s accurate.</p>
<h2>Chat Room as Multi-Agent Workspace</h2>
<p>TIA agents operate in XMPP (Jabber) chat rooms, creating a shared environment where autonomous agents and humans collaborate on equal footing. This chat-based approach offers several advantages for LLM-powered agents: the text-based, turn-taking conversation model aligns naturally with how LLMs process information; asynchronous messaging allows agents time for reasoning and external API calls; and the persistent transcript provides context that agents can reference during problem-solving.</p>
<p>For humans, chat rooms provide a familiar interface requiring no specialized tools—any XMPP client works. Users can observe agent deliberations in real-time, intervene when needed, and learn from watching how agents decompose and solve problems. The federated nature of XMPP means agents can run on different servers while participating in the same conversation, and the protocol&#39;s maturity provides reliable message delivery and reconnection handling.</p>
<p>This creates a workspace where structured semantic protocols (RDF models, SHACL validation, SPARQL queries) flow beneath a human-readable conversation layer. Agents exchange Turtle serializations and validation reports through Lingue protocol negotiation, while humans see natural language summaries. The chat transcript becomes an audit trail showing both the social coordination (who said what, when) and the semantic artifacts (models, constraints, solutions) produced during problem-solving.</p>
<h2>Overview</h2>
<p>TIA (The Intelligence Agency) applies semantic web technologies to multi-agent coordination. The system implements Model-First Reasoning, where specialized agents collaboratively construct explicit RDF problem models before generating solutions. All configuration, capabilities, and problem representations use RDF throughout.</p>
<h2>Semantic Web Technologies in Use</h2>
<h3>RDF Problem Models</h3>
<p>Problem models are RDF graphs expressed in the MFR (Model-First Reasoning) ontology. Each contribution from an agent becomes a named graph with provenance metadata. The coordinator merges these graphs and validates them against SHACL shapes before reasoning begins.</p>
<p>Example model fragment:</p>
<pre><code class="language-turtle">@prefix mfr: &lt;http://purl.org/stuff/mfr/&gt; .
@prefix schema: &lt;http://schema.org/&gt; .

&lt;#entity-alice&gt; a mfr:Entity ;
  schema:name &quot;Alice&quot; ;
  mfr:contributedBy &lt;#mistral-agent&gt; ;
  owl:sameAs &lt;http://www.wikidata.org/entity/Q...&gt; .

&lt;#constraint-temporal&gt; a mfr:Constraint ;
  mfr:constraintType &quot;temporal&quot; ;
  rdfs:comment &quot;Alice only available in morning&quot; ;
  mfr:contributedBy &lt;#semantic-agent&gt; .
</code></pre>
<h3>SHACL Validation</h3>
<p>Model completeness and consistency are enforced through SHACL shapes. The coordinator validates merged contributions to ensure:</p>
<ul>
<li>Required entity properties are present</li>
<li>Actions have defined preconditions and effects</li>
<li>Goals are properly specified</li>
<li>Constraints reference valid entities</li>
</ul>
<p>Validation failures trigger a negotiation phase where agents can propose amendments.</p>
<h3>RDF-Based Configuration</h3>
<p>Agent profiles are RDF Turtle files declaring capabilities, supported language modes, and XMPP credentials. The mistral-base profile defines common LLM settings, which specialized variants inherit using RDF property inheritance:</p>
<pre><code class="language-turtle">@prefix agent: &lt;https://tensegrity.it/vocab/agent#&gt; .
@prefix lng: &lt;http://purl.org/stuff/lingue/&gt; .

&lt;#coordinator&gt; a agent:ConversationalAgent ;
  agent:nickname &quot;Coordinator&quot; ;
  lng:supports lng:ModelFirstRDF, lng:ModelNegotiation, lng:ShaclValidation ;
  agent:capability mfr:Orchestration, mfr:Validation .
</code></pre>
<h3>The Lingue Protocol</h3>
<p>Agents negotiate language modes through the Lingue protocol, a lightweight semantic layer over XMPP. When two agents need to exchange structured data, they negotiate compatible serializations:</p>
<ul>
<li><code>lng:ModelFirstRDF</code> - RDF model fragments (Turtle)</li>
<li><code>lng:SparqlQuery</code> - SPARQL queries for knowledge retrieval</li>
<li><code>lng:PrologProgram</code> - Logic programs</li>
<li><code>lng:IBISText</code> - Issue-Based Information System dialogue</li>
<li><code>lng:ShaclValidation</code> - Validation reports</li>
</ul>
<p>This allows heterogeneous agents to collaborate without prior agreement on data formats.</p>
<h3>Knowledge Grounding</h3>
<p>The Data agent grounds entities to Wikidata URIs via SPARQL queries, adding <code>owl:sameAs</code> links to the problem model. This connects problem-specific entities to authoritative knowledge bases:</p>
<pre><code class="language-sparql">SELECT ?item ?itemLabel WHERE {
  ?item rdfs:label &quot;warfarin&quot;@en .
  SERVICE wikibase:label { bd:serviceParam wikibase:language &quot;en&quot; }
}
</code></pre>
<h2>Architecture Highlights</h2>
<p><strong>Agent Specialization</strong>: Each agent contributes domain-specific RDF:</p>
<ul>
<li>Mistral extracts entities and goals from natural language</li>
<li>Data grounds entities to Wikidata/DBpedia URIs</li>
<li>Prolog models actions with preconditions and effects</li>
<li>MFR Semantic identifies constraints and validates consistency</li>
<li>Golem receives its system prompt at runtime, allowing it to adapt to problem-specific roles (logic-focused reasoning, domain expertise, etc.)</li>
</ul>
<p><strong>Runtime Adaptability</strong>: The system adjusts its behavior based on problem characteristics. When a user poses a question (using the <code>Q:</code> prefix), the Coordinator initiates a planning poll where agents debate which reasoning approach to use: logic-based (Prolog), consensus-based (debate), or adaptive (Golem with specialized role). This meta-reasoning step allows the system to route problems to appropriate solution strategies. The Golem agent exemplifies this adaptability—its role and capabilities are defined at runtime through RDF-based configuration rather than fixed at deployment.</p>
<p><strong>Protocol Flow</strong>:</p>
<ol>
<li>Problem interpretation → RDF entity extraction</li>
<li>Entity grounding → <code>owl:sameAs</code> links to knowledge bases</li>
<li>Constraint identification → RDF constraint definitions</li>
<li>Model merging → Unified RDF graph</li>
<li>SHACL validation → Conformance checking</li>
<li>Constrained reasoning → Solution generation within model bounds</li>
</ol>
<p><strong>Provenance Tracking</strong>: Every RDF statement includes <code>mfr:contributedBy</code> metadata, enabling conflict resolution and explanation generation.</p>
<h2>Current Status</h2>
<p>The system demonstrates end-to-end functionality: users pose problems in natural language, agents construct and validate RDF models, and solutions are generated with full provenance. The MFR ontology, SHACL shapes, and agent profiles are under active development.</p>
<p><strong>Live System</strong>: Agents operate on a federated XMPP server at <code>tensegrity.it</code>. You can join the conversation at <code>general@conference.tensegrity.it</code> using any XMPP client.</p>
<p><strong>Code &amp; Documentation</strong>: <a href="https://github.com/danja/tia">https://github.com/danja/tia</a>
<strong>Live Chat</strong>: <a href="https://tensegrity.it/chat/">https://tensegrity.it/chat/</a></p>
<h2>Technical Foundation</h2>
<ul>
<li><strong>Ontologies</strong>: Custom MFR ontology plus Schema.org and domain vocabularies</li>
<li><strong>RDF Library</strong>: rdflib.js for graph manipulation and serialization</li>
<li><strong>SHACL</strong>: shacl-engine for validation</li>
<li><strong>SPARQL</strong>: Query external endpoints (Wikidata, DBpedia)</li>
<li><strong>Transport</strong>: XMPP for federated messaging</li>
<li><strong>Serialization</strong>: Turtle for human readability</li>
<li><strong>MCP Integration</strong>: TIA exposes a Model Context Protocol server, enabling development with Claude Code and Codex CLI. External clients can send messages to chat rooms, retrieve conversation history, and initiate Lingue protocol negotiations through MCP tools.</li>
</ul>
<h2>Open Questions</h2>
<p>The project raises interesting questions about semantic web technologies in multi-agent systems:</p>
<ol>
<li>How should provenance be represented when multiple agents contribute conflicting information?</li>
<li>Can SHACL shapes effectively capture domain constraints for constraint-based reasoning?</li>
<li>What vocabulary design patterns work best for agent capability negotiation?</li>
<li>How can RDF-based models support both machine reasoning and human explanation?</li>
</ol>
<p>Feedback and collaboration from the semantic web community would be valuable. The system is open source and welcomes contributions.</p>

    </main>
  </body>
</html>